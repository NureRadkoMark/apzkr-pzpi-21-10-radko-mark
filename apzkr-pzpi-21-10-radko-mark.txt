Міністерство освіти і науки України 
Харківський національний університет радіоелектроніки 
 
 
Факультет комп’ютерних наук 
 
 
Кафедра програмної інженерії 
 
 
КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: Програмна система для керування мережею ветеринарних клінік
 
 
 	    Студент гр. ПЗПІ-21-10 	 	_________________ Радько М.М. 
 	 	 	 	 	 	 	(підпис) 
 	    Керівник роботи 	 	 	_________________ доц. Лещинська І.О. 
 	 	 	 	 	 	 	(підпис) 
 	 	 	 	 	 	 	      Роботу захищено «__» ______ 2024.р 
 	 	 	 	 	 	 	      з оцінкою _______________________ 
 	    Комісія:  	 	 	 	_______________ доц. Лещинський В.О. 
 	 	 	 	 	 	 		 	(підпис) 
 	 	 	 	 	 	 	_______________ доц. Лещинська І.О. 
 	 	 	 	 	 	 		 	(підпис) 
 	 	 	 	 	 	 	_______________ ст. викл. Сокорчук І.П. 
 	 	 	 	 	 	 		 	(підпис) 
Харків 
2024 р. 
Харківський національний університет радіоелектроніки 

Факультет комп’ютерних наук		Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення				
Курс 		3	Семестр 				6					
Навчальна дисципліна Архітектура програмного забезпечення			

ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ 

					Радько Марку Максимовичу					
1.	Тема роботи: «Програмна система для керування мережею ветеринарних клінік			                     								
2.	Термін узгодження завдання курсової роботи «11»		березня	2024 р.
3.	Термін здачі студентов закінченої роботи «15»	червня	2024
4.	Вихідні дані до проекту (роботи): У програмній системі передбачити: додавання нового філіалу, робітників, оптимальне управління філіалами мережі, відстеження стану робітників. Використовувати ОС Windows 10 або 11, СКБД PostgreSQL, середовище розробки WebStorm						
5.	Зміст пояснювальної записки (перелік питань, що належить розробити) вступ, аналііз предметної області, постановка задачі, проектування програмного проекту, структуру бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань на джерела, додатки        											     	  
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма станів, UML – діаграма взаємодії, UML діаграма діяльності, UML діаграма пакетів, UML діаграма компонентів, інтерфейс веб – застосунку, інтерфейс мобільного застосунку, будова IoT – пристрою				



КАЛЕНДАРНИЙ ПЛАН
 

 
№ 	Назва етапів курсової роботи 	Термін виконання етапів роботи 	Примітка 
1 	Функціональна специфікація програмного проекту 	05.03.2024 	 Виконано
2 	Проектування програмного проекту 	20.03.2024 	 Виконано
3 	Кодування програмного проекту 	20.04.2024 	 Виконано
4 	Оформлення пояснювальної записки 	20.05.2024 	 Виконано
5 	Захист курсової роботи 	09.06.2024 	 Виконано
 
 
	Дата видачі завдання «   11   »  	березня 	 2024 р. 
 
 	 	Керівник   	 	 	 	                     доц. Лещинська І.О. 
 	 	 	 	 	 	 	 	(підпис) 
 	 	 
Завдання прийняв до виконання 
	ст. гр. ПЗПІ-21-10 	 	 	 	      Радько М.М. 
	 	 	 	 	 	     (підпис) 






РЕФЕРАТ


Пояснювальна записка до курсової роботи: 69 с., 11 рис., 3 табл., 7 додатків, 7 джерел.
МЕРЕЖА КЛІНІК, УПРАВЛІННЯ, ВЕТЕРИНАРІЯ, СИСТЕМА, ПАЦІЄНТИ, ОБЛАДНАННЯ, КЛІЄНТИ, ТВАРИНИ, РОБОЧИЙ ЧАС.

Об'єктом дослідження курсової роботи є ефективне управління мережею ветеринарних клінік. Це питання є надзвичайно актуальним, оскільки оптимальне використання ресурсів та координація діяльності клінік сприяє підвищенню якості ветеринарних послуг, що особливо важливо в сучасних умовах.
Метою курсової роботи є створення комплексної програмної системи для управління мережею ветеринарних клінік. Система буде зберігати дані про клініки, пацієнтів, обладнання та процедури, що необхідно виконувати. Використовуючи спеціальні пристрої та програми, система зможе координувати роботу клінік та ефективно розподіляти ресурси.
Розробка системи базується на таких технологіях:  СУБД PostgreSQL, Node.js з фреймворком Express для серверної частини, IoT пристрої на базі Arduino з мікроконтролером ESP32, сканером для сканування індивідуального коду працівників та клієнтів, веб-клієнт на JavaScript з використанням React, а також мобільний додаток на Kotlin для Android.
Результатом курсової роботи має стати складна програмна система, яка дозволить найбільш оптимально управляти мережею ветеринарних клінік. Система буде складатися з серверної частини, IoT пристроїв, веб-клієнта та мобільного додатка. Усі компоненти будуть інтегровані в єдину програмну систему та взаємодіяти між собою для забезпечення ефективного управління клініками.


ЗМІСТ


Вступ	8
1 Vision and Scope документ	9
1.1 Бізнес - вимоги	9
1.1.1 Передумови	9
1.1.2 Бізнес - можливості	9
1.1.3Бізнес цілі та критерії	12
1.1.4 Потреби клієнтів та ринку	13
1.1.5 Бізнес - ризики	14
1.2 Концепція рішення	15
1.2.1 Окреслення концепції	15
1.2.2 Головна функціональність	16
1.2.3 Припущення та залежності	17
1.3 Рамки та обмеження	18
1.3.1 Рамки первинного випуску	18
1.3.2 Рамки наступних випусків	21
1.3.3 Обмеження та виключення	22
1.4 Бізнес – контекст	23
1.4.1 Профілі зацікавлених сторін	23
1.4.2 Пріоритети проєкту	26
1.4.3 Робоче середовище	29
2 Проектування програмного проєкту	31
2.1 Загальне проектування системи	31
2.2 Проектування серверної частини	32
2.3 Проектування IoT пристрою	34
2.4 Проектування веб – застосунку	36
3 Структура бази даних	41
4 Кодування програмного проєкту	43
4.1 Загальне кодування системи	43
4.2 Кодування серверної частини	43
4.3 Кодування IoT пристрою	44
4.4 Кодування веб-застосунку	45
4.5 Кодування мобільного застосунку	46
Висновки	48
Перелік джерел посилань	49
Додаток А REST Специфікація	50
Додаток Б Створення запису на прийом до ветеринара   55
Додаток В Підрахування сумми накладної користувача в особовому кабінеті	59
Додаток Г Програмний код IoT пристрою	61
Додаток Д Перевірка дійсності JWT токена   67
Додаток Ж Перевірка на плагіат	69


ВСТУП


У сучасному світі, ветеринарні клініки відіграють важливу роль у забезпеченні здоров'я та благополуччя тварин. Однак ефективне управління мережею таких клінік може бути складним завданням через необхідність координації багатьох аспектів, включаючи розподіл ресурсів, моніторинг стану пацієнтів, управління обладнанням та забезпечення якості послуг.
Метою цієї курсової роботи є створення «Програмної системи для оптимального управління мережею ветеринарних клінік». Ця система дозволить централізовано зберігати та обробляти інформацію про клініки, пацієнтів, ветеринарів та обладнання, що використовується. Використовуючи сучасні технології, система зможе забезпечити ефективний моніторинг та управління всіма аспектами роботи клінік.
Для досягнення цієї мети розробка включає кілька ключових компонентів: серверну частину для обробки даних, веб-застосунок для адміністрування, IoT пристрої для сканування індивідуального коду працівників клінік та клієнтів та мобільний додаток для доступу до інформації з будь-якого місця.
У ході роботи використовувалися такі технології: PostgreSQL для управління базами даних, Node.js та Express для серверної частини, Arduino з мікроконтролером ESP32 та датчиками для створення IoT пристроїв, а також React для розробки веб-клієнта та Kotlin для мобільного додатка на платформі Android.
Результатом виконання курсової роботи стане комплексна програмна система, яка інтегрує всі зазначені компоненти в єдине ціле, забезпечуючи ефективне управління мережею ветеринарних клінік, покращуючи координацію, підвищуючи якість обслуговування та оптимізуючи роботу ветеринарів і обладнання.


1 VISION AND SCOPE ДОКУМЕНТ
1.1 Бізнес - вимоги


1.1.1	Передумови
       
          
Сучасні ветеринарні клініки стикаються з чисельними викликами в управлінні своїми операціями, особливо, коли йдеться про мережу клінік, філіяли якої знаходяться в різних географічних точках. Відсутність єдиної системи управління призводить до проблем з координацією між клініками, неефективного використання ресурсів та ускладнень у веденні документації. 
Координація графіків лікарів та персоналу, управління запасами медикаментів і обладнання, зростаючі очікування клієнтів щодо якості та швидкості надання ветеринарних послуг вимагають більш досконалих рішень.
З розвитком технологій з’являються нові можливості для оптимізації бізнес процесів у сфері ветеринарії. Інтеграція інформаційних систем дозволяє не лише покращити якість обслуговування пацієнтів, але й значно підвищити ефективність управління клінікою. Завдяки сучасним програмним рішенням ветеринарні клініки можуть автоматизувати рутинні процеси, забезпечити точність і доступність даних, а також поліпшити взаємодію між різними підрозділами та пацієнтами.


1.1.2	Бізнес – можливості


Ринок ветеринарних послуг демонструє стійке зростання завдяки збільшенню кількості домашніх тварин, зростаючій свідомості власників про необхідність якісного медичного догляду за своїми улюбленцями та розширенню спектру доступних ветеринарних послуг, що призводить до виникання систем – аналогів майбутнього програмного продукту. Роздивемось деякі з них.
По – перше, розглянемо програмну систему Avimark (https://software.covetrus.com/veterinary-solutions/avimark-veterinary appointment-scheduling/), яка є одним з найпопулярніших програмних рішень для управління ветеринарними клініками в Північній Америці. Система пропонує широкий спектр функцій, включаючи управління електронними медичними записами (ЕМЗ), планування зустрічей, управління запасами, фінансовий облік та звітність.
Avimark використовує клієнт-серверну архітектуру, де програмне забезпечення встановлюється на комп'ютери клієнтів, а база даних зберігається на сервері клініки.
Система забезпечує централізоване управління даними, автоматизацію рутинних завдань, інтеграцію з лабораторними та діагностичними системами. Вона також надає інструменти для фінансового обліку та управління запасами, що допомагає оптимізувати операційні процеси.
По – друге, розглянемо систему Cornestone (https://www.inploi.com/integrations/cornerstone), яка є комплексною системою управління ветеринарними клініками та пропонує функціонал для автоматизації процесів, включаючи бухгалтерський облік, управління ЕМЗ, планування та управління клієнтами.
Система побудована на основі локальної архітектури з можливістю розгортання в локальній мережі клініки. Вона також підтримує інтеграцію з хмарними сервісами для забезпечення доступності даних.
Cornerstone фокусується на інтеграції всіх аспектів роботи клініки, включаючи управління фінансами, пацієнтами та запасами. Система автоматизує процеси та забезпечує точність даних через інтеграцію з лабораторними та діагностичними системами.
Іншим аналогом розроблюваної системи є платформа eVetPractice (https://login.evetpractice.com), яка є хмарною платформою для управління ветеринарними клініками та пропонує широкий набір функцій, включаючи мобільний доступ, управління ЕМЗ, планування зустрічей, інтеграцію з лабораторними сервісами та постачальниками.
eVetPractice працює на основі хмарної архітектури, що дозволяє користувачам отримувати доступ до системи через веб-браузер або мобільні додатки. Всі дані зберігаються в хмарному сховищі, що забезпечує їх доступність і захищеність.
Платформа забезпечує мобільність і гнучкість, дозволяючи ветеринарам працювати з будь-якої точки світу з доступом до інтернету. Система інтегрується з лабораторіями та постачальниками, що спрощує управління процесами та запасами. Вона також надає інструменти для аналітики та звітності, що допомагають оптимізувати роботу клініки.
Враховуючи поточні ринкові умови та конкурентну ситуацію, система управління мережею ветеринарних клінік буде використовувати наступні моделі монетизації:
– Підписка (SaaS) – основний дохід може надходити від щомісячних або щорічних підписок на доступ до платформи, що забезпечить стабільний потік доходів та дозволить клієнтам обирати відповідний для них пакет послуг.
– Інтеграції та додаткові модулі – пропонування додаткових платних модулів та інтеграцій з іншими сервісами (лабораторії, аптеки, постачальники медичних товарів) дозволить отримувати додаткові доходи.
– Аналітичні сервіси – преміальна послуга з надання детальних звітів та аналітичних даних, які допомагають клінікам оптимізувати свою роботу та приймати обґрунтовані управлінські рішення. 
Розроблювана програмна система орієнтована на європейський та північноамериканський ринки корпоративних систем, які демонструють високий потенціал для розвитку завдяки наступним факторам:
– Висока концентрація ветеринарних клінік: В обох регіонах існує велика кількість ветеринарних клінік та мереж, що забезпечує значний попит на корпоративні системи управління.
– Зрілість ринку. Ринок ветеринарних послуг у Європі та Північній Америці є високорозвиненим з точки зору технологій та інфраструктури. Це сприяє впровадженню сучасних інформаційних систем.
– Регулювання та стандартизація. В обох регіонах існують суворі регуляторні вимоги щодо ведення медичних записів та управління клініками, що стимулює клініки до використання якісних програмних рішень.
– Сприйнятливість до нових технологій. Клініки в Європі та Північній Америці активно впроваджують нові технології для підвищення ефективності та якості обслуговування пацієнтів.


1.1.3	Бізнес цілі та критерії


Проект має наступні бізнес цілі:
- Забезпечення ефективного управління клінічними процесами;
- Забезпечення ефективної комунікації клінік з клієнтами;
- Забезпечення безпеки даних, конфіденційності та надійності програмної системи;
- Забезпечення масштабованості та гнучкості;
- Підвищення рівня осблуговування клієнтів клінік та покращення їх задоволенності.
Проект має наступні критерії для оцінки успіху проекту:
- Повернення інвестицій не менше ніж на 50% від витрат на розробку програмної системи протягом першого року;
- Підписання угод з не менше ніж 30 великими ветеринарними мережами протягом першого року;
- Досягнення не менше ніж 800 зареєстрованих користувачів у системі протягом першого року;
- Збільшення рівня задоволеності клієнтів, виміряного за допомогою опитувань клієнтів, на 20% протягом перших 6 місяців використання системи;
- Зменшення часу на обробку адміністративних процесів на не менше ніж 20% протягом першого року використання системи.
- Зменшення часу, потрібного для оформлення медичної документації на 30% протягом перших 6 місяців використання системи;
- Збільшення кількості записів на консультації через онлайн-систему на 50% протягом перших 3 місяців впровадження системи;
- Досягнення сертифікації за стандартом кібербезпеки ISO 27001 протягом першого року використання системи.


1.1.4	Потреби клієнтів та ринку


Для досягнення успіху проекту необхідно визначити потреби та вимоги як клієнтів, так і ринку.
Потреби ринку:
- Гнучкість та масштабованість;
- Підвищення ефективності надання послуг;
- Оптимізаця витрат;
- Потреба у цифровізації;
- Залучення клієнтів шляхом  впровадження конкурентних програмних рішень.
Потреби клієнтів:
- Зручна система запису та прийому;
- Висока захищеність даних;
- Ефективне управління медичними даними;
- Підтримка від розробників.


1.1.5	Бізнес – ризики


Розробка та впровадження програмної системи управління мережею ветеринарних клінік супроводжується низкою бізнес-ризиків, які необхідно враховувати для успішної реалізації проекту:
- Ризик невідповідності технічним вимогам. Можливість того, що розроблена система не буде відповідати всім необхідним технічним вимогам, що може призвести до проблем з її впровадженням та використанням;
- Проблеми з інтеграцією. Складнощі, що можуть виникнути при інтеграції нової системи з вже існуючими системами та програмним забезпеченням клінік;
- Збої та помилки у системі. Можливість виникнення збоїв та помилок у роботі програмної системи, що може вплинути на її надійність та репутацію;
- Перевищення бюджету. Ризик того, що витрати на розробку та впровадження системи можуть перевищити запланований бюджет;
- Низька окупність інвестицій. Можливість того, що система не зможе забезпечити очікуваний рівень доходу та повернення інвестицій у встановлені терміни;
- Конкуренція. Висока конкуренція на ринку програмного забезпечення для ветеринарних клінік може ускладнити залучення нових клієнтів та утримання існуючих;
- Зміни у ринкових умовах. Непередбачувані зміни в економічних та ринкових умовах можуть вплинути на попит на програмну систему;
- Низький рівень прийняття системи користувачами. Можливість того, що персонал клінік та клієнти можуть не прийняти нову систему через складність її використання або небажання змінювати звичні процеси;
- Високі вимоги до навчання. Необхідність тривалого та складного навчання персоналу для роботи з новою системою може стати перешкодою для її впровадження;
- Невідповідність законодавчим вимогам. Ризик того, що програмна система не буде відповідати всім законодавчим та регуляторним вимогам у сфері захисту даних та надання медичних послуг;
– Проблеми з ліцензуванням. Можливість виникнення проблем з отриманням необхідних ліцензій та дозволів для впровадження та використання системи. 


1.2 Концепція рішення


1.2.1 Окреслення концепції


Метою проекту є розробка та впровадження інноваційної програмної системи управління мережею ветеринарних клінік, яка дозволить ефективно керувати клінічними процесами, забезпечить високу якість обслуговування клієнтів та відповідатиме сучасним вимогам ринку.
Програмна система повинна забезпечити зручний та ефективний облік медичних даних, керувати записами клієнтів та підтримувати планування прийомів. Також потрібно запровадити систему зворотнього зв’язку для підвищення рівня задоволеності клієнтів та підтримувати можливість адаптації продукту до потреб клінік незалежно від їх розміру та структури. Важливим аспектом майбутньої системи є забезпечення можливості інтеграції з іншими  сервісами та платформами для розширення функціональності. 


1.2.2 Головна функціональність


Програмна система управління мережею ветеринарних клінік включає широкий спектр функцій, розроблених для забезпечення ефективного та зручного управління клінічними процесами. Для повноцінної працездатності майбутньої системи має бути реалізований наступний функціонал:
- Реєстрація та авторизація користувачів;
- Реєстрація мережі ветеринарних клінік у системі та додавання нових клінік;
- Оформлення підписки на сервіс;
- Управління розкладом лікарів та автоматизація планування прийомів;
- Можливість онлайн-запису на прийом для клієнтів через веб-сайт або мобільний додаток;
- Зберігання та організація медичних даних пацієнтів;
- Автоматизоване введення даних та генерація звітів;
- Наявність системи сповіщень та нагадувань про прийоми та медичні процедури;
- Ведення фінансової звітності та аналітики;
- Генерація детальних звітів про роботу клініки, фінансові показники та ефективність надання послуг;
Система контролю доступу та обліку робочого часу. 


1.2.3 Припущення та залежності


Для успішної реалізації та впровадження програмної системи управління мережею ветеринарних клінік необхідно враховувати низку припущень та залежностей, які можуть вплинути на хід проекту. 
Проект має наступні парипущення:
- Передбачається, що всі ветеринарні клініки мають доступ до стабільного та швидкого інтернет-з'єднання для безперебійної роботи системи;
- Клініки забезпечені сучасним комп'ютерним обладнанням, що відповідає мінімальним технічним вимогам для роботи програмного забезпечення;
- Персонал клінік буде мати достатній рівень навичок для роботи з новою системою після проведення відповідного навчання;
- Адміністрація клінік забезпечить участь персоналу у всіх необхідних тренінгах та навчальних сесіях;
- Програмна система буде розроблена з урахуванням чинного законодавства та регуляторних вимог щодо захисту даних та медичних послуг;
- Всі необхідні ліцензії та дозволи для впровадження системи будуть отримані вчасно;
- Фінансування на розробку, впровадження та підтримку системи буде забезпечене в повному обсязі протягом усього періоду реалізації проекту;
- Витрати на навчання персоналу та технічну підтримку будуть враховані в бюджеті проекту;
- Клієнти (ветеринарні клініки) будуть готові прийняти та впровадити нову систему в своїй щоденній практиці;
- Адміністрація клінік буде підтримувати активну комунікацію з розробниками для своєчасного вирішення можливих проблем.
Проект має наступні залежності:
- Підтримка актуальних API для забезпечення безшовної інтеграції;
- Надійність та стабільність роботи зовнішніх сервісів та технологій, що використовуються у системі;
- Вчасне проведення оновлень програмного забезпечення для покращення функціональності та виправлення можливих помилок;
- Доступність технічної підтримки для користувачів системи у разі виникнення проблем; 
- Відповідність системи новим законодавчим та регуляторним вимогам, які можуть виникнути після її впровадження;
- Адаптація системи до змін у правовому полі та нових стандартів безпеки даних;
– Активна участь користувачів у наданні зворотного зв'язку для постійного покращення системи. 


1.3 Рамки та обмеження


1.3.1 Рамки первинного випуску


Початковий випуск програмної системи управління мережею ветеринарних клінік включатиме основні функції, необхідні для ефективного управління клінічними процесами та забезпечення високої якості обслуговування клієнтів:
Серверна/back-end частина:
- Реєстрація. Кожен користувач повинен мати можливість створити акаунт у системі;
- Авторизація. Зареєстрований користувач повинен мати змогу увійти в систему, використовуючи свою електронну пошту та пароль;
- Оформлення підписки. Зареєстровані користувачі повинні мати можливість оформлення підписки на сервіс;
- Додавання мережі. Після оформлення підписки користувачі можуть додати свою мережу до системи;
- Додавання працівників. Після додавання мережи до системи акаунт користувача набуває статусу адміністратора. Адміністратор повинен створити акаунти працівників у своїй мережі;
- Адміністратор повинен мати можливість розділяти акаунти працівників на лікарів, медсестер та партнерів;
- Адміністратор повинен мати доступ до імпорту/експорту даних з бази даних, до створення резервних копій;
- Одностороннє шифрування паролів та резервних копій;
- Система повинна забезпечувати швидку обробку даних і відповідати на запити користувачів у режимі реального часу;
- Система повинна бути здатною до розширення та адаптації до збільшення кількості користувачів та обсягу даних;
- Має бути можливість легко додавати нові функціональні можливості без необхідності значних змін у системі;
- Адміністратор повинен мати можливість налаштування та адміністрування системи.
Клієнтська/front-end частина:
- Інтерфейс. Користувачі повинні мати зручний та інтуїтивно зрозумілий інтерфейс програмної системи;
- Локалізація. Інтерфейс повинен підтримувати англійську та українську мови та можливість перемикання між ними;
- Перегляд даних. Інтерфейс адміністратора повинен підтримувати можливість перегляду даних робітників мережі та даних про їх робочий час; 
- Запис на прийом. Клієнт повинен мати можливість запису на прийом до лікаря;
- Клієнт повинен мати можливість перегляду даних про прийом, медичної картки свого улюбленця та рецепту;
- Електронний чек. Клієнт повинен мати можливість формування електронного чеку за надані послуги;
- Розклад. Лікар повинен мати можливість перегляду свого розкладу прийомів;
- Лікар повинен мати можливість написання електронного рецепту.
IoT пристрої:
- Сканування індивідуального коду працівника та клієнта;
- Відправлення коду на серверну частину системи;
- Отримання відповіді від серверної частини після відправлення відсканованого коду;
- Спрацювання автоматичного турнікету після отримання позитивної відповіді серверної частини.
Мобільний застосунок/Mobile:
- Реєстрація. Кожен користувач повинен мати можливість створити акаунт у системі;
- Авторизація. Зареєстрований користувач повинен мати змогу увійти в систему, використовуючи свою електронну пошту та пароль;
- Запис на прийом. Клієнт повинен мати можливість запису на прийом до лікаря;
- Статус прийому. Клієнт повинен мати можливість перегляду статусу запису до лікаря;
- Написання рецептів. Лікар повинен мати можливість написання рецептів;
- Розклад прийомів. Лікар повинен мати можливість перегляду розкладу прийомів.


1.3.2 Рамки наступних випусків


Для забезпечення подальшого розвитку та розширення функціональних можливостей програмної системи управління мережею ветеринарних клінік, у наступних випусках планується реалізувати такі функції та покращення:
- Інтеграція з додатковими зовнішніми сервісами, такими як постачальники медичного обладнання та програмного забезпечення для управління складськими запасами;
- Можливість створення користувацьких звітів для аналізу різних аспектів роботи клініки;
- Забезпечення можливості проведення відеоконсультацій між лікарями та клієнтами;
- Створення корпоративних чатів між лякарями та клієнтами;
- Постійне вдосконалення інтерфейсу для забезпечення зручності та інтуїтивності користування системою;
- Локалізація інтерфейсу та документації для різних регіонів;
- Впровадження додаткових інструментів для управління графіками роботи, відпустками та навчанням працівників;
- Автоматизація процесів оцінки продуктивності та підвищення кваліфікації працівників;
- Підключення до різноманітних платіжних шлюзів для зручної оплати послуг клієнтами;
- Автоматизація процесів виставлення рахунків та обробки платежів;
– Розширення функціональності для покращення взаємодії з клієнтами, включаючи управління зверненнями, нагадування про прийоми та спеціальні пропозиції. 


1.3.3 Обмеження та виключення


Програмна система управління мережею ветеринарних клінік має наступні обмеження та виключення.
Проект має наступні обмеження:
- Закони та нормативні акти різних країн можуть регулювати обробку даних працівників і клієнтів, вимагаючи суворого дотримання норм конфіденційності та безпеки;
- Деякі ветеринарні клініки вже використовують інші програмні системи. Для успішної інтеграції нової системи можуть знадобитися додаткові налаштування та адаптація;
- Для повноцінного функціонування системи клініки повинні бути обладнані розумними пристроями (IoT), такими як сканери кодів для реєстрації присутності працівників та турнікети;
- Використання застарілого апаратного та програмного забезпечення у деяких клініках може ускладнити роботу нової системи, вимагаючи модернізації інфраструктури.
Проект має наступні виключення:
- Всі компоненти системи залежать від стабільної роботи Інтернету. Проблеми з мережею можуть призвести до переривання роботи та несумісності компонентів системи;
- Оновлення програмного або апаратного забезпечення може спричинити проблеми сумісності з існуючими компонентами системи, що вимагатиме додаткових налаштувань;
- Зміни у законодавстві щодо обробки персональних даних або вимоги до безпеки можуть вимагати адаптації системи та її політик, що призведе до додаткових витрат і часу на оновлення;
- Система може бути вразлива до кібератак, що може призвести до втрати конфіденційних даних клінік і персоналу. Необхідно впроваджувати надійні механізми захисту даних.


1.4 Бізнес – контекст


1.4.1 Профілі зацікавлених сторін


Для успішної розробки та впровадження програмної системи важливо визначити та врахувати інтереси ключових зацікавлених сторін. Заповнимо таблицю (див. таблицю 1.1), де пропишемо профілі зацікавлених сторін, їх ставлення до проекту, інтереси та основні цінності.


Таблиця 1.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Власники ветеринарних клінік	Оптимізація роботи, збільшення прибутковості	Позитивне, прагматичне	Покращення якості обслуговування клієнтів	Законодавчі обмеження, інтеграція з існуючими системами
Адміністратори клінік	Ефективне управління персоналом, спрощення процесів	Позитивне, практичне	Управління графіками, облік присутності, звітність	Застаріле апаратне забезпечення

Лікарі	Зручний доступ до інформації, зменшення паперової роботи	Позитивне, очікувальне	Доступ до медичних записів, планування прийомів	Проблеми з Інтернетом, інтеграція з іншими системами
Медичний персонал	Полегшення повсякденної роботи, зменшення помилок 	Позитивне, підтриму-вальне	Інтуїтивний інтерфейс, автоматизація завдань	Технічні обмеження,  наявність розумних пристроїв
Клієнти	Швидке та якісне обслуговування, 	Позитивне, вимогливе	Онлайн-запис, нагадування, доступ до 	Законодавчі обмеження, конфіденцій-ність даних
	Продовження таблиці 1.1
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
	зручність запису		історії лікування	
Інвестори та партнери	Рентабельність інвестицій, стабільний розвиток	Позитивне, аналітичне	Прозорість фінансових показників, план розвитку	Ризик кібератак, ринкові коливання
Розробники та технічна підтримка	Зручність розробки та підтримки, сучасні технології	Позитивне, конструктив-не	Документова-на архітектура, тестування та відлагодження	Застаріле апаратне забезпечен-ня, оновлення системи
Маркетологи та відділ продажу	Збільшення кількості користувачів, утримання клієнтів	Позитивне, амбітне	Аналітика ринку, рекламні кампанії	Зміни у законодав-стві, ринкові коливання
Юридичний відділ	Дотримання законодавства, захист конфіденційної інформації	Позитивне, суворе	Відповідність нормативним вимогам, захист даних	Законодавчі обмеження, зміни у законодав-стві
Продовження таблиці 1.1
Зацікавлена сторона	Основна цінність	Ставлення	Основні інтереси	Обмеження
Постачальники IT-рішень та обладнання	Стабільна співпраця, зростання попиту	Позитивне, співробітниц-ке	Чіткі технічні вимоги, інтеграція з іншими системами	Технічні обмеження, сумісність обладнання


1.4.2 Пріоритети проєкту


Заповнимо таблицю, де пропишемо пріоритети проекту (див. таблицю 1.2). Занесемо до таблиці план робіт, якості програмного продукту, функціонал та пріоритети.

Таблиця 1.2 – пріоритети проекту
Показник виконання	Етапи	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
Термін впровадження	Початок розробки – березень 2024 року	Впровадження не пізніше червня 2024 року	Допустима затримка до 2 місяців
Бюджет проекту	Планування бюджету, розподіл ресурсів	Максимальний бюджет – $50	Допустиме перевищення до 15%
Продовження таблиці 1.2
Показник виконання	Етапи	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
Функціональність системи	Впровадження ключових функцій	Всі ключові функції мають бути реалізовані	Допускаються незначні відкладення другорядних функцій
Якість продукту	Розробка, тестування, впровадження	Відсутність критичних помилок	Допускаються незначні помилки, які не впливають на основну роботу системи
Кількість користувачів	Залучення перших клієнтів, маркетингова кампанія	Мінімум 800 користувачів за перший рік	Допускається зменшення до 15% від запланованого числа
Інтеграція з іншими системами	Розробка модулів інтеграції	Інтеграція з мінімум 5 сторонніми системами	Допускається поступова інтеграція, якщо це не впливає на основну функціональність 
Продовження таблиці 1.2
Показник виконання	Етапи	Обмеження (граничні значення)	Ступінь свободи (допустимий діапазон)
Безпека даних	Впровадження механізмів захисту даних	Відсутність витоків даних	Допускаються незначні вразливості, що не становлять критичної загрози
Задоволеність клієнтів	Збір зворотного зв'язку, впровадження покращень	Мінімум 85% позитивних відгуків	Допускається зниження до 80% за умови, що буде впроваджено план покращення
Технічна підтримка	Створення служби підтримки користувачів	Відповідь на запити протягом 24 годин	Допускається збільшення до 48 годин у пікові періоди
Масштабованість системи	Тестування під великим навантаженням	Підтримка до 10,000 користувачів одночасно	Допускається зниження до 8,000 за умови, що будуть проведені роботи з оптимізації


1.4.3 Робоче середовище


Програмна система повинна працювати в наступному робочому середовищі:
- Операційна система: Windows 10 або новіша, macOS 10.15 або новіша, сучасні дистрибутиви Linux;
- Браузери: Google Chrome 90 або новіша версія, Mozilla Firefox 88 або новіша версія, Safari 14 або новіша версія;
- Мобільні платформи: iOS 13 або новіша, Android 9 або новіша;
- Підключення: Wi-Fi або Ethernet;
- Мережеві вимоги: Постійне підключення до Інтернету зі швидкістю не менше 100 Мбіт/с;
- Протоколи: Підтримка стандартів IoT (MQTT, CoAP);
- Типи пристроїв: Сканери штрих-кодів, турнікети з  Wi-Fi;
- Шифрування: Використання SSL/TLS для захисту даних при передачі;
- Захист баз даних: Шифрування даних у базі даних, регулярне створення резервних копій, хешування паролів;
- Серверне обладнання: Мінімальні вимоги: 8 ядерний процесор, 32 ГБ оперативної пам'яті, 1 ТБ SSD;
- База даних: PostgreSQL 12 або новіша версія;
- Серверна\back-end частина буде розроблена на платформі Node.js, з використанням фреймворку Express.js;
- Клієнтська\front-end частина буде розроблена за допомогою бібліотеки React з  використанням react-router-dom, Bootstrap та Axios для Http запитів;
- IoT або SmartDevice пристрої будуть розроблені за допомогою мови Arduino Sketch;
- Mobile застосунок буде розроблений за допомогою мовипрограмування Kotlin.


2 ПРОЕКУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
2.1 Загальне проектування системи


UML – діаграма розгортання моделює фізичну архітектуру програмної системи, демонструє усі компоненти та зв’язки між ними. UML – діаграма розгортання наведена на рисунку 2.1.

 
Рисунок 2.1 - Діаграма розгортання

Для розроблюваної системи обрана СУБД PostgreSQL. Для зв’язку бази даних з сервером використовується відповідний драйвер pg – hstore.
Cерверна частина системи взаємодіє з базою даних за допомогою фреймворку express. Також сервер заємодіє з IOT пристроєм, клієнтським застосунком та мобільною платформою за допомогою протоколу HTTPS.
Доступ до клінтської частини та мобільної платформи відбувається за допомогою персонального комп’ютеру та мобільного пристрою відповідно. 


2.2 Проектування серверної частини


Під час проектування серверної частини була побудована діаграма прецентів. UML – діаграма прецедентів візуалізує функціональність системи та її взаємодію з акторами, тобто з користувачами або іншими ситемами (див. рисунок 2.2).

 
Рисунок 2.2 – UML діаграма прецедентів для серверної частини

Як ми бачимо, в програмній системі передбачено 4 види звичайних користувачів: незареєстрований користувач, зареєстрований користувач, лікар та робітник мережі ветеринарних клінік. Незареєстрований користувач має можливість лише зареєструватися та авторизуватися в системі. Зареєстрований користувач може оформити підписку на сервіс, після чого може зареєструвати свою мережу. Лікар може сканувати свій індивідуальний код на вході до клініки для запису часу початку робочого дня, передивлятись календар записів до нього та виписувати рецепт пацієнтам. Робітник може лише використовувати систему для запису початку та кінця робочого дня на турнікеті.
Система має 3 види адміністраторів: власник мережі, адміністратор мережі, системний адміністратор. Системний адміністратор – головний адміністратор програмної системи, який може керувати усією базою даних, керувати сутностями та створювати резервні копії. Адміністратор мережі може керувати робочим складом, тобто додавати, видаляти, блокувати акаунти робітників, слідкувати за їх робочим часом. Власник мережі має усі повноваження адміністратора мережі, крім того він може редагувати дані про компанію та передивлятись статус підписки на програмну систему.
Розробка UML-діаграми станів спрямована на моделювання поведінки системи, враховуючи її різні стани та події, що впливають на ці стани. Діаграма станів дозволяє візуалізувати, як система реагує на зовнішні та внутрішні події, як змінюються її стани у відповідь на ці події, та які умови необхідні для переходу між станами. UML – діаграма станів наведена на рисунку 2.3.
Дана діаграма станів ілюструє бізнес – логіку з запису користувача на прийом до лікаря. Спочатку користувач обирає місто, дату та час для запису на прийом. Потім система обирає робітника з відповідних філіалів та перевіряє, чи є робітник лікарем, якщо ні, то система обирає  наступного робітника. Далі відбувається перевірка, чи є у лікаря «вікно» для прийому, якщо ні, то система обирає наступного працівника. Далі відбувається запис на прийом.
 
Рисунок 2.3 – UML - діаграма станів для серверної частини


2.3 Проектування IoT пристрою


Спочатку розробимо UML – діаграму прецедентів під часи проектування IoT пристрою (див рисунок 2.4). Діаграма включає двох основних акторів: користувача системи, який використовує IoT пристрій, та сервер, куди розумний пристрій передає дані.
Користувач може вмикати та вимикати пристрій. Крім того він може сканувати свій персональний код та отримувати пропуск від пристрою. Сканований код буде відправлений на сервер та оброблений.

 
Рисунок 2.4 - UML - діаграма прецедентів

UML - діаграма взаємодії зображує взаємодію об’єктів системи між собою у певному випадку використання (див. рисунок 2.5). Вона показує роботу методів та викликів між об’єктами системи за певного сценарію.

 
Рисунок 2.5 - UML - діаграма взаємодії

Як ми бачимо, спочатку розумний пристрій сканує індивідуальний код користувача. Далі цей код відправляється на серверну частину програмної системи, після чого відбувається перевірка бази даних та відправляється відповідь. В залежності від отриманої відповіді IoT пристрій надає або блокує доступ.


2.4 Проектування веб – застосунку


Проектування програмної системи розпочнемо зі створення UML – діаграми (див. рисунок 2.6), які дозволять визначити функції, які мають бути реалізовані, компоненти системи та їх взаємодію, бізнес – процеси системи та інше. Вона візуалізує функціональність системи та її взаємодію з акторами, тобто з користувачами або іншими ситемами. 

 
Рисунок 2.6 – UML діаграма прецедентів для веб – застосунку

Як ми бачимо, в програмній системі передбачено 4 види звичайних користувачів: незареєстрований користувач, зареєстрований користувач, лікар та робітник мережі ветеринарних клінік. Незареєстрований користувач має можливість лише зареєструватися та авторизуватися в системі. Зареєстрований користувач може оформити підписку на сервіс, після чого може зареєструвати свою мережу. 
Система має 3 види адміністраторів: власник мережі, адміністратор мережі, системний адміністратор. Системний адміністратор – головний адміністратор програмної системи, який може керувати усією базою даних, керувати сутностями та створювати резервні копії. Адміністратор мережі може керувати робочим складом, тобто додавати, видаляти, блокувати акаунти робітників, слідкувати за їх робочим часом. Власник мережі має усі повноваження адміністратора мережі, крім того він може редагувати дані про компанію та передивлятись статус підписки на програмну систему.
Далі створимо діаграму пакетів, для визначення архітектури веб-клієнту (див. рисунок 2.7).

 
Рисунок 2.7 – UML діаграма пакетів для веб – застосунку
Клієнтська частина містить наступні пакети: 
- App – кореневий пакет застосунку;
- Pages – пакет, який містить сторінки, які бачить користувач;
- Components – пакет з різними UI компонентами;
- Locales – пакет з файлом локалізації для перекладу сторінок на різні мови;
- Utills – пакет з файом, який містить маршрути;
- Styles – пакет з CSS стилями.


2.5 Проектування мобільного застосунку


Створимо UML – діаграму прецедентів, де покажемо взаємодію мобільної частини програмної системи з користувачами (див. рисунок 2.8)

 
Рисунок 2.8 - UML діаграма прецедентів для мобільного застосунку
Як ми бачимо, мобільний застосунок має три види користувача: не  авторизований користувач, клієнт та лікар. 
Не авторизований користувач може лише авторизуватися або зареєструватися у системі.
Клієнт має можливість запису до лікаря, переглядати власні записи до лікаря, та інтерфейс з керування власними тваринами (видалення, зміна та додавання нової тварини). Також у клієнта у мобільному застосунку повинен бути власний код для сканування на вході до клініки.
Лікар має можливість перегляди власний розклад, створювати рецепти. Також він має код для сканування на вході до клініки.
Створимо UML – діаграму пакетів для наглядного зображення архітектури мобільного застосунку (див. рисунок 2.9).

Рисунок 2.9 – UML діаграма пакетів для мобільного застосунку
Мобільний застосунок має наступні директорії:
̶- App – має головний файл, точка для входу в програму;
̶- Models – пакет, що містить моделі;
̶- Controllers – пакет, що містить контролери;
̶- Views – пакет, що містить представлення, які використані у мобільному застосунку;
̶- Network – пакет, який відповідає за взаємодію з серверною частиною;
̶- Adapters – пакет для виводу даних у вигляді списків;
̶- Utills – допоміжні частини;
̶- Res – Android ресурси.


3 СТРУКТУРА БАЗИ ДАНИХ


Для проекту було обрано реляційну базу даних PostgreSQL. Цей вибір обґрунтовано її здатністю структурувати дані за допомогою таблиць, що сприяє забезпеченню цілісності даних та транзакційної безпеки. PostgreSQL відома своєю масштабованістю, високою продуктивністю, великою спільнотою користувачів, а також підтримкою широкого спектру вбудованих функцій.
ER - модель даних розробляється для відображення та візуалізації структури бази даних, зосереджуючись на сутностях і їх зв'язках. ER-модель показана на рисунку 3.1.

 
Рисунок 3.1 - ER – модель даних
ER-діаграма, що описує систему управління мережею ветеринарних клінік, включає наступні сутності:
̶- Компанія. Містить всю інформацію про мережі ветеринарних клінік, включаючи назву, адресу головного офісу та інші контактні дані;
̶- Філіал. Представляє інформацію про окремі філіали в мережі, включаючи їх адреси, контактні дані та належність до конкретної компанії;
̶- Користувач. Включає дані про користувачів програмної системи, зокрема імена, контактні дані та іншу необхідну інформацію;
̶- Роль. Описує різні ролі, які можуть виконувати користувачі, такі як адміністратор, ветеринар, асистент тощо;
̶- Робітник. Містить інформацію про працівників клінік, включаючи їхні імена, контактні дані, посади та інші відповідні деталі;
̶- Чек. Містить інформацію про чеки користувачів, включаючи деталі транзакцій та наданих послуг;
̶- Сервіс. Описує послуги, які можуть надавати клініки, такі як огляди, вакцинації, операції тощо;
̶- Тварина. Містить інформацію про тварин, включаючи їхні імена, види, породи, вік та інші медичні дані;
̶- Підписка. Зберігає дані про підписку користувачів на програмну систему;
̶- Запис до лікаря. Містить інформацію про записи користувачів до лікарів, включаючи дату, час та лікаря, до якого зроблено запис;
̶- Рецепт. Включає дані про виписані лікарями рецепти, зокрема назви препаратів, дозування та інструкції щодо застосування;
̶- Робочі часи робітника. Описує графік роботи кожного працівника клініки, включаючи дні та години роботи.


4 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
4.1 Загальне кодування системи


До GitHub репозиторію[4] був завантажений джерельний код усіх компонентів програмної системи. Також на платформі YouTube опублікований відеоролік[5] з демонстрацією функціонального тестування усіх частин програмної системи. 


4.2 Кодування серверної частини


Серверна / back-end частина написана на програмній платформі Node JS, з використанням фреймворку Express JS та мови програмування JavaScript.
Архітектура проекту реалізована за моделлю MVC (Model-View-Controller). Модель відповідає за управління даними та бізнес-логікою застосунку. Всі взаємодії з базою даних виконуються за допомогою ORM Sequelize, що полегшує маніпулювання даними та забезпечує інтеграцію з PostgreSQL. Модель також включає всі бізнес-правила та валідації, необхідні для забезпечення коректності даних.
Представлення відповідає за інтерфейс користувача або API, через який користувач взаємодіє з системою. Це веб-інтерфейс, створений за допомогою фронтенд технологій, і REST API, який забезпечує зв’язок між сервером і клієнтськими компонентами системи.
Контролер відповідає за обробку запитів від користувачів, взаємодію з моделями для отримання або оновлення даних, та передачу відповідних відповідей до представлення. Контролер використовує програмну платформу Node.js та фреймворк Express.js.
Взаємодія між клієнтськими компонентами та сервером здійснюється за допомогою REST API (див. додаток А). Авторизація користувачів виконується через JSON Web Token (JWT). Після успішної авторизації або реєстрації користувача генерується токен, який містить необхідні дані та має строк дії 24 години, після закінчення якого користувачу необхідно буде повторно авторизуватися.
Ще одним прикладом бізнес логіки в програмній системі є створення запису на прийом до ветеринара (див. додаток Б). Спочатку користувач обирає місто, дату та час для запису на прийом. Потім система обирає робітника з відповідних філіалів та перевіряє, чи є робітник лікарем, якщо ні, то система обирає  наступного робітника. Далі відбувається перевірка, чи є у лікаря «вікно» для прийому, якщо ні, то система обирає наступного працівника. Далі відбувається запис на прийом.
Також є використання математичних методів, таких, як підрахування сумми накладної користувача в особовому кабінеті (див. додаток В). 


4.3 Кодування IoT пристрою


Для розробки розумного пристрою використовувався емулятор Wokwi та платформа Arduino.
Сам IoT пристрій складається з контроллеру ESP32 з вбудованою підтримкою Wi-Fi, червоного та зеленого світлодіодів, цифрової клавіатури для імітації сканування коду, та сервомеханізму, який імітує турнікет.
Взаємодія пристрою за REST API відбувається по протоколу HTTP.
Перейдемо до опису програмного коду (див. додаток Г). На початку прописуються піни для підключення усіх компонентів пристрою, URL сервера для відправлення запиту та дані для підключення до мережі. Далі у функції setup() відбувається підключення до мережі, налаштування світлодіодів, клавіатури та сервомеханізму. Функція turnServo() відповідає за поворот сервомеханізму в залежності від значення. Функція verifyCode відповідає за відправлення HTTP запиту на серверну частину та отримання відповіді, обробку помилок, пов’язаних з запитом. Основна логіка програмного коду знаходиться у функції loop(), де обробляється натискання на кнопки клавіатури, вмикання світлодіодів та обертання сервомеханізму.


4.4 Кодування веб-застосунку


Для розробки клієнтської частини застосунку використано JavaScript та React. Взаємодія із сервером здійснюється за допомогою вбудованого компонента для HTTP-запитів — функції fetch. Інформація відображається з використанням бібліотеки i18n, яка підтримує англійську та українську мови.
Клієнтська частина обмінюється даними з сервером виключно через HTTP-запити, для яких використовується fetch. Клієнтська частина побудована за принципом SPA (Single Page Application), що означає, що сторінка завантажується один раз і динамічно оновлюється без повного перезавантаження. Вся логіка зосереджена в одному компоненті, і активно використовуються React-гачки «useState» та «useEffect».
Важливий аспект роботи системи — це авторизація на клієнтській частині. Вона здійснюється за допомогою JWT токенів, які сервер надсилає у відповідь на запити про авторизацію. На сервері паролі хешуються односторонньо. Отриманий JWT токен зберігається в localStorage браузера (див. Додаток Д). Під час завантаження та відкриття сторінки токен відправляється на сервер для перевірки його дійсності.
Маршрутизація, яка є ключовим елементом функціонування веб-застосунку, реалізована за допомогою бібліотеки react-router-dom. Файл з маршрутами для кожної сторінки знаходиться у папці Utils, а основний файл Routes, який зв'язує маршрути зі сторінками, розташований у корені проекту. 


4.5 Кодування мобільного застосунку


Застосунок розробляється для використання на мобільній платформі Android. 
Взаємодія з серверною частиною програмної системи буде відбуватися за протоколом HTTP, за допомогою бібліотеки Retrofit.
Для написання програмного коду обрана мова Kotlin та середовище розробки Android Studio. 
У мобільному застосунку реалізовано архітектуру MVC, яка розділяє його на три основні компоненти:
- Model — відповідає за дані та змінює свій стан у відповідь на дії контролера;
- Controller — обробляє дії користувача та відповідно змінює моделі;
- View — відображає дані для користувача і реагує на зміни в моделях.
Ця архітектура сприяє розподілу відповідальності, що відповідає одному з принципів SOLID[6][7], і робить застосунок легким для підтримки та масштабування.
У мобільному застосунку буде реалізована взаємодія з серверною частиною, яка відповідає за основну бізнес – логіку програмної системи, а саме – запис на прийом до ветеринара. Користувач повинен обрати місто, дату та час для запиту. Після чого система розподіляє запити між лікарями ветеринарних лікарень в залежності від загрузки ветеринарів та місць розташування.


ВИСНОВКИ


У рамках виконання курсової роботи було розроблено комплексну програмну систему для керування мережею ветеринарних клінік. Система складається з кількох компонентів: серверної частини, веб-застосунку, IoT-пристрою та мобільного додатка. Усі ці компоненти інтегруються в єдину систему та взаємодіють між собою.
Для визначення потреб ринку та зацікавлених сторін, а також для розробки необхідного функціоналу було створено документ Vision and Scope, який містить відповіді на ці питання. Після цього було розроблено UML-діаграми (діаграми прецедентів, пакетів, станів, взаємодії та активності), що дозволило з'ясувати структуру, функціональність і логіку кожного компонента системи. Далі проведено проектування системи та було визначено архітектурні підходи для кожного компоненту з метою забезпечення їх масштабованості, можливості рефакторингу коду та тестування.
Наступним кроком було кодування компонентів системи із використанням відповідних технологій (Node JS, React, Arduino, Kotlin, Express, Retrofit, Sequelize, React-router-dom, i18n тощо). У результаті виконання всіх цих етапів було створено складну програмну систему для керування робочим персоналом ветеринарних клінік.
Програмна система має бути застосована у мережах ветеринарних клінік для керування робочим складом, спрощення процедур запису до лікарів, взаємодії між клієнтами та кліінками. Доданий IoT пристрій для ведення автоматичного обліку робочого часу працівників та пропуску клієнтів та робітників на територію клінік.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАНЬ


1. Covetrus Ascend, your practice wherever you need it. URL: https://software.covetrus.com/emea/ (дата звернення: 26.03.2024).
2. Optimise your candidate experience with our Cornerstone integration URL: https://www.inploi.com/integrations/cornerstone (дата звернення: 25.03.2024).
3. Pulse™ Login URL: https://login.evetpractice.com (дата звернення: 26.03.2024).
4. GitHub - NureRadkoMark/apzkr-pzpi-21-10-radko-mark. GitHub. URL:  (дата звернення: 06.06.2024).
5. Радько Марк. Apzkr-pzpi-21-10-radko-mark, 2024. YouTube. URL:  https://youtu.be/DpYq5eEuTmM (дата звернення: 06.06.2024).
6. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
7. Martin Fowler. Refactoring. Improving the Design of Existing Code– Addison-Wesley Professional, 1999. – 464 с.


ДОДАТОК А
Специфікація REST


Таблиця А.1 – REST – специфікація
Контролер	Метод	URL	Опис
«Користувач»	POST	api/user/register	Реєстрація користувача
	POST	api/user/login	Авторизація користувача
	PUT	api/user/ban	Блокування користувача
	PUT	api/user/unban	Розблокування користувача
	PUT	api/user/update	Оновлення даних про користувача
	GET	api/user/details	Отримання даних про користувача
	GET	api/user/check	Оновлення JWT токену
	PUT	api/user/code	Пошук користувача по коду
«Пристрій»	POST	api/device/start	Початок зміни IoT
	POST	api/device/end	Кінець зміни IoT



Продовження таблиці А.1
Контролер	Метод	URL	Опис
«Послуга»	POST	api/service/	Створення нової послуги
	PUT	api/service/	Оновлення даних про послугу
	DELETE	api/service/	Видалення послуги
	PUT	api/service/user	Додавання послуги до накладної користувача
	GET	api/service/department	Отримання послуг клініки
«Роль»	POST	api/role/	Створення нвої ролі
	GET	api/role/all	Отримання всях ролей
	GET	api/role/user	Отримання ролі користувача
	PUT	api/role/role	Оновлення ролі користувача
«Рецепт»	POST	api/prescription/	Створення рецепту
	POST	api/pet	Додавання нової тварини


Продовження таблиці А.1
Контролер	Метод	URL	Опис
«Тварина»	GET	api/pet/user	Отримання тварин користувача
	GET	api/pet/id	Отримання тварини по Id
«Робітник»	POST	api/employee/	Додавання робітника
	PUT	api/employee/	Зміна даних робітника
	DELETE	api/employee/	Видалення робітника
	GET	api/employee/department/
doctors	Отримання лікарів клініки
	PUT	api/employee/department	Отримання робітників клініки
	PUT	api/employee/hours/
department	Отримання робочих часів робітників клініки
«Чек»	POST	api/check/new	Створення нового чека 
	GET	api/check/department	Отримання накладної клініки
	GET	api/check/user	Отримання накладної 


Продовження таблиці А.1
Контролер	Метод	URL	Опис
«Філіал»	POST	api/department/	Створення філіалу
	DELETE	api/department/	Видалення філіалу
	PUT	api/department/search	Пошук філіалу за адресою
	PUT	api/department/	Зміна даних про філіал
	PUT	api/department/details	Отримання даних про філіал
	PUT	api/department/company	Отримання філіалів однієї мережі
«Компанія»	POST	api/company/	Створення мережі клінік
	PUT	api/company/	Зміна даних про мережу
	DELETE	api/company/	Видалення мережі
	PUT	api/company/details	Отримання даних про мережу 
	GET	api/company/user	Пошук мережі по ролі в JWT користувача 
	GET	api/company/admin	


Продовження таблиці А.1
Контролер	Метод	URL	Опис
«Запис до ветеринара»	POST	api/appointment	Створення запису до лікаря
	PUT	api/appointment/update	Зміна запису
	DELETE	api/appointment/	Видалення запису
	GET	api/appointment/user	Отримання записів користувача
	GET	api/appointment/employee	Отримання записів до лікаря
«Резервні копії»	POST	api/backup	Створення резервної копії бази даних та файлової системи
	GET	api/backup/download	Отримання посилання на завантаження архіву з резервними копіями


ДОДАТОК Б
Створення запису на прийом до ветеринара


1.  async create(req, res) {
2.      let preferredLang;
3.      try {
4.          const { PetId, DateAndTime, DepartmentId, Lang } = req.body;
5.          let dateAndTime;
6.          preferredLang = Lang;
7.
8.          const parsedDate = moment(DateAndTime, 'YYYY-MM-DD HH:mm', true);
9.          if (!parsedDate.isValid()) {
10.             return res.status(400).json({ error: 'Invalid date format' });
11.         }
12.         dateAndTime = parsedDate.toDate();
13.
14.         if (moment(dateAndTime).isBefore(moment())) {
15.             return res.status(400).json({ error: 'Appointment time must be in the future' });
16.         }
17.
18.         const department = await Department.findByPk(DepartmentId);
19.         if (!department) {
20.             return res.status(404).json({ error: 'Department not found' });
21.         }
22.
23.         const startWorkingTime = moment(department.StartWorkingTime, 'HH:mm');
24.         const endWorkingTime = moment(department.EndWorkingTime, 'HH:mm');
25.
26.         const appointmentTime = moment(dateAndTime).format('HH:mm');
27.
28.         if (appointmentTime < startWorkingTime.format('HH:mm') || appointmentTime > endWorkingTime.format('HH:mm')) {
29.             return res.status(400).json({ error: 'Appointment time is outside of department working hours' });
30.         }
31.
32.         const doctors = await Employee.findAll({
33.             where: {
34.                 DepartmentDepartmentId: DepartmentId,
35.                 Role: 'Doctor'
36.             }
37.         });
38.
39.         let selectedDoctor = null;
40.         for (const doctor of doctors) {
41.             const existingAppointment = await Appointment.findOne({
42.                 where: {
43.                     EmployeeEmployeeId: doctor.EmployeeId,
44.                     DateAndTime: {
45.                         [Op.and]: [
46.                             { [Op.gte]: moment(dateAndTime).subtract(15, 'minutes').toDate() },
47.                             { [Op.lte]: moment(dateAndTime).add(15, 'minutes').toDate() }
48.                         ]
49.                     }
50.                 }
51.             });
52.             if (!existingAppointment) {
53.                 selectedDoctor = doctor;
54.                 break;
55.             }
56.         }
57.
58.         if (selectedDoctor) {
59.             const appointment = await Appointment.create({
60.                 EmployeeEmployeeId: selectedDoctor.EmployeeId,
61.                 PetPetId: PetId,
62.                 DateAndTime: dateAndTime
63.             });
64.             return res.status(201).json(appointment);
65.         } else {
66.             return res.status(404).json({ error: 'No available appointment' });
67.         }
68.
69.     } catch (error) {
70.         console.error("Unexpected error:", error);
71.         return res.status(500).json({ error: 'Internal server error' });
72.     }
73. }


ДОДАТОК В
Підрахування сумми накладної користувача в особовому кабінеті


1.  async calculateTotalAmount(checkId) {
2.      try {
3.          console.log(`Calculating total amount for checkId: ${checkId}`);
4.
5.          // Get services in the check from DB
6.          const servicesInCheck = await ServiceInCheck.findAll({
7.              where: { CheckCheckId: checkId },
8.              include: [
9.                  {
10.                     model: Service
11.                 }
12.             ]
13.         });
14.
15.         if (!servicesInCheck || servicesInCheck.length === 0) {
16.             console.warn(`No services found for the given checkId: ${checkId}`);
17.             return 0; // Return 0 if no services found
18.         }
19.
20.         console.log(`Found ${servicesInCheck.length} services in the check`);
21.
22.         const totalAmount = servicesInCheck.reduce((total, serviceInCheck) => {
23.             if (!serviceInCheck.Service) {
24.                 console.error('Service not found for serviceInCheck:', serviceInCheck);
25.                 throw new Error('Service not found for serviceInCheck');
26.             }
27.             return total + (serviceInCheck.Service.Price * serviceInCheck.Count);
28.         }, 0);
29.
30.         return totalAmount;
31.     } catch (error) {
32.         console.error('Error in calculateTotalAmount:', error);
33.         return 0; // Return 0 in case of any error
34.     }
35. }


ДОДАТОК Г
Програмний код для IoT пристрою


1.  #include <WiFi.h>
2.  #include <HTTPClient.h>
3.  #include <ArduinoJson.h>
4.  #include <Keypad.h>
5.
6.  // WiFi configuration
7.  const char* ssid = "Wokwi-GUEST";
8.  const char* password = "";
9.  const char* serverName = "http://host.wokwi.internal:5000/api/device/start"; // Server URL
10.
11. // Servo and LED parameters
12. const int ledPinRed = 2;   // Pin for red LED
13. const int ledPinGreen = 13; // Pin for green LED
14. const int servoPin = 5;    // Pin for servo (changed to 5)
15. const int servoMin = 500;  // Minimum pulse width for servo (500 microseconds)
16. const int servoMax = 2400; // Maximum pulse width for servo (2400 microseconds)
17.
18. // Keypad configuration
19. const byte ROWS = 4; // four rows
20. const byte COLS = 4; // four columns
21. char keys[ROWS][COLS] = {
22.   {'1', '2', '3', 'A'},
23.   {'4', '5', '6', 'B'},
24.   {'7', '8', '9', 'C'},
25.   {'*', '0', '#', 'D'}
26. };
27. byte rowPins[ROWS] = {23, 22, 21, 19}; // Connect to the row pins
28. byte colPins[COLS] = {18, 17, 16, 15}; // Connect to the column pins
29.
30. Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
31.
32. String code = "";
33.
34. void setup() {
35.   Serial.begin(115200);
36.   Serial.println("ESP32 started");
37.
38.   WiFi.begin(ssid, password, 6);
39.   Serial.print("Connecting to WiFi");
40.   while (WiFi.status() != WL_CONNECTED) {
41.     delay(100);
42.     Serial.print(".");
43.   }
44.   Serial.println("\nConnected to WiFi");
45.
46.   pinMode(ledPinRed, OUTPUT);
47.   pinMode(ledPinGreen, OUTPUT);
48.
49.   // Configure the channel for servo control
50.   ledcSetup(0, 50, 16); // channel 0, frequency 50 Hz, 16-bit resolution
51.   ledcAttachPin(servoPin, 0);
52.
53.   Serial.println("Enter 7-digit code:");
54. }
55.
56. void loop() {
57.   char key = keypad.getKey();
58.   if (key) {
59.     if (key >= '0' && key <= '9') {
60.       code += key;
61.       Serial.print(key);
62.     } else if (key == '#') {
63.       Serial.println();
64.       if (code.length() == 7) {
65.         Serial.println("Sending code to server: " + code);
66.         if (verifyCode(code)) {
67.           turnServo(90); // Turn the servo to 90 degrees
68.           digitalWrite(ledPinGreen, HIGH); // Turn on the green LED
69.           delay(1000); // Wait for 5 seconds
70.           turnServo(0); // Return the servo to the initial position
71.           delay(1000); // Wait for 5 seconds
72.           turnServo(90); // Turn the servo to 90 degrees
73.           digitalWrite(ledPinGreen, LOW); // Turn off the green LED
74.         } else {
75.           digitalWrite(ledPinRed, HIGH); // Turn on the red LED
76.           delay(5000); // Wait for 5 seconds
77.           digitalWrite(ledPinRed, LOW); // Turn off the red LED
78.         }
79.         code = ""; // Reset the entered code
80.         Serial.println("Enter 7-digit code:");
81.       } else {
82.         Serial.println("Invalid code length. Enter 7-digit code:");
83.         code = "";
84.       }
85.     } else if (key == '*') {
86.       code = "";
87.       Serial.println("\nCode reset. Enter 7-digit code:");
88.     }
89.   }
90. }
91.
92. void turnServo(int angle) {
93.   int pulseWidth = map(angle, 0, 180, servoMin, servoMax);
94.   int dutyCycle = (pulseWidth * pow(2, 16)) / 20000; // For 16-bit resolution
95.   ledcWrite(0, dutyCycle);
96. }
97.
98. bool verifyCode(String code) {
99.   if (WiFi.status() == WL_CONNECTED) {
100.    HTTPClient http;
101.    http.begin(serverName);
102.    http.addHeader("Content-Type", "application/json");
103.
104.    String jsonPayload = "{\"IOTCode\": \"" + code + "\"}";
105.    Serial.println("JSON Payload: " + jsonPayload);
106.
107.    int httpResponseCode = http.POST(jsonPayload);
108.
109.    if (httpResponseCode > 0) {
110.      String response = http.getString();
111.      Serial.println("HTTP Response code: " + String(httpResponseCode));
112.      Serial.println("Response: " + response);
113.
114.      DynamicJsonDocument doc(200);
115.      deserializeJson(doc, response);
116.
117.      bool exists = doc["exists"];
118.      http.end();
119.      return exists;
120.    } else {
121.      Serial.println("Error on sending POST: " + String(httpResponseCode));
122.      if (httpResponseCode == HTTPC_ERROR_CONNECTION_REFUSED) {
123.        Serial.println("Connection refused");
124.      } else if (httpResponseCode == HTTPC_ERROR_SEND_HEADER_FAILED) {
125.        Serial.println("Send header failed");
126.      } else if (httpResponseCode == HTTPC_ERROR_SEND_PAYLOAD_FAILED) {
127.        Serial.println("Send payload failed");
128.      } else if (httpResponseCode == HTTPC_ERROR_NOT_CONNECTED) {
129.        Serial.println("Not connected");
130.      } else if (httpResponseCode == HTTPC_ERROR_CONNECTION_LOST) {
131.        Serial.println("Connection lost");
132.      } else if (httpResponseCode == HTTPC_ERROR_NO_STREAM) {
133.        Serial.println("No stream");
134.      } else if (httpResponseCode == HTTPC_ERROR_NO_HTTP_SERVER) {
135.        Serial.println("No HTTP server");
136.      } else if (httpResponseCode == HTTPC_ERROR_TOO_LESS_RAM) {
137.        Serial.println("Too less RAM");
138.      } else if (httpResponseCode == HTTPC_ERROR_ENCODING) {
139.        Serial.println("Encoding error");
140.      } else if (httpResponseCode == HTTPC_ERROR_STREAM_WRITE) {
141.        Serial.println("Stream write error");
142.      } else if (httpResponseCode == HTTPC_ERROR_READ_TIMEOUT) {
143.        Serial.println("Read timeout");
144.      }
145.      http.end();
146.      return false;
147.    }
148.  } else {
149.    Serial.println("WiFi Disconnected");
150.    return false;
151.  }
152. }


ДОДАТОК Д
Перевірка дійсності JWT токена


1.  export default async function refreshToken() {
2.      const storedToken = localStorage.getItem('jwtToken');
3.
4.      if (storedToken) {
5.          try {
6.              const url = 'http://localhost:5000/api/user/check';
7.              const response = await fetch(url, {
8.                  method: 'PUT',
9.                  headers: {
10.                     'Content-Type': 'application/json',
11.                     'Authorization': `${storedToken}`,
12.                 },
13.             });
14.
15.             const responseData = await response.json();
16.
17.             if (response.ok) {
18.
19.                 const newToken = responseData.token;
20.
21.                 localStorage.setItem('jwtToken', newToken);
22.
23.             } else {
24.                 window.location.href = '/login';
25.             }
26.         } catch (error) {
27.             console.error('Error checking and refreshing token:', error);
28.         }
29.     }
30. }


ДОДАТОК Ж
Перевірка на плагіат

 
Рисунок Ж.1 – Результат перевірки на плагіат
